## clip-path 实现不规则图形及溢出场景

本章节开始介绍新的属性 `clip-path`，该元素主要用于裁剪元素的可视区域。

### clip-path 基本用法

`clip-path` 的基本语法如下：

```css
clip-path: [ shape() | url()] | none;
```

`clip-path` 可以接受一个 `shape()` 函数，也可以接受一个 `url()` 函数，还可以接受 `none`，表示不裁剪。

`shape()` 函数可以接受 `inset()`, `circle()`, `ellipse()`, `polygon()` 等函数，这些函数都是裁剪的形状。`url()` 函数可以接受一个 SVG 的 URL，表示裁剪的形状。

常见的裁剪形状如下：

```css
/* 裁剪为圆形 */
clip-path: circle(50px at center);
/* 裁剪为椭圆 */
clip-path: ellipse(50px 30px at center);
/* 裁剪为矩形 */
clip-path: inset(10px 20px 30px 40px);
/* 裁剪为多边形 */
clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
```

效果如下图所示：

![运行效果](https://pic1.imgdb.cn/item/68f0a2ccc5157e1a8878d595.png)

> 具体效果可查看 [clip-path 基本用法](https://codepen.io/duyidao/pen/vELWgGx)

`clip-path` 括号内的参数都是元素的坐标点，这些坐标点都是相对于元素左上角的位置。

`clip-path` 直接写会不太方便，社区有一些在线生成工具，可以帮助开发者更好的使用 `clip-path`，比如 [CSS clip-path](https://bennettfeely.com/clippy/)。它包含了多种常用的图形，并且可以调整图形坐标的参数，底部还能实时更新最新的参数代码。

![CSS clip-path界面](https://pic1.imgdb.cn/item/68f0ae8cc5157e1a8878f21a.png)

### 用 clip-path 实现常见不规则图形

还是用之前的例子，之前使用 `mask` 实现了内切角的效果，现在可以借助 `clip-path` 快速实现效果，这样背景色可以直接任意定制，无论是渐变还是纯色都不在话下。

```css
div {
  width: 200px;
  height: 100px;
  background: linear-gradient(45deg, #ff7e5f, #feb47b);
  clip-path: polygon(
    15px 0,
    calc(100% - 15px) 0,
    100% 15px,
    100% calc(100% - 15px),
    calc(100% - 15px) 100%,
    15px 100%,
    0 calc(100% - 15px),
    0 15px
  );
}
```

![效果](https://pic1.imgdb.cn/item/68f0b312c5157e1a88790623.png)

毫无疑问，在实现不规则多边形效果上，`clip-path` 比 `mask` 更为直观，而且代码量更少。再对比一下，如果想要实现下方这个箭头图形效果呢？

![箭头效果](https://pic1.imgdb.cn/item/68f0b70ac5157e1a887907f5.png)

如果用 `mask` ，虽然也可以做到，但是代码量会很繁琐，如果用 `clip-path`，很轻松就能实现效果。

```css
div {
  width: 200px;
  height: 100px;
  margin: 0 auto;
  background: linear-gradient(90deg, skyblue, blue);
  clip-path: polygon(
    0 0,
    calc(100% - 50px) 0,
    100% 50%,
    calc(100% - 50px) 100%,
    0 100%,
    50px 50%
  );
}
```

> 具体效果可查看 [clip-path 实现不规则图形](https://codepen.io/duyidao/pen/KwVyWdw)

### clip-path 的局限性

前面介绍了 `clip-path` 如何通过裁剪实现不规则图形效果，但是 `clip-path` 并不是万能的，它也有一些局限性。

它最大的局限性在于，无法作用完整的边框。还是以上方两个例子为例，各自添加一个边框，看看效果如何。

```css
div {
  border: 2px solid #333;
}

.foo {
  width: 200px;
  height: 100px;
  margin: 0 auto 20px;
  background: linear-gradient(45deg, #ff7e5f, #feb47b);
  clip-path: polygon(
    15px 0,
    calc(100% - 15px) 0,
    100% 15px,
    100% calc(100% - 15px),
    calc(100% - 15px) 100%,
    15px 100%,
    0 calc(100% - 15px),
    0 15px
  );
}

.box {
  width: 200px;
  height: 100px;
  margin: 0 auto;
  background: linear-gradient(90deg, skyblue, blue);
  clip-path: polygon(
    0 0,
    calc(100% - 50px) 0,
    100% 50%,
    calc(100% - 50px) 100%,
    0 100%,
    50px 50%
  );
}
```

![加上边框后的效果](https://pic1.imgdb.cn/item/68f0ba37c5157e1a8879231d.png)

这是因为 `clip-path` 实际做的是切割图形，而边框实际作用在整体 `div` 上，因此被切割后的部分无法显示边框。

那么，如果在切割裁剪完图形之后，又想要添加边框，该如何实现呢？

### filter: drop-shadow()

`box-shadow` 是给整个盒子添加阴影效果，而 `drop-shadow()` 是创建一个符合当前元素本身形状的阴影，因此可以使用这个黑科技，给切割后的图形添加阴影，视觉上实现边框效果。

::: code-group

```html
<div class="father">
  <div class="foo"></div>
</div>
<div class="father">
  <div class="box"></div>
</div>
```

```css
.father {
  width: 200px;
  height: 100px;
  background: transparent;
  margin: 0 auto 20px;
  filter: drop-shadow(0 0 1px #000);
}

.foo {
  width: 200px;
  height: 100px;
  margin: 0 auto 20px;
  background: linear-gradient(45deg, #ff7e5f, #feb47b);
  clip-path: polygon(
    15px 0,
    calc(100% - 15px) 0,
    100% 15px,
    100% calc(100% - 15px),
    calc(100% - 15px) 100%,
    15px 100%,
    0 calc(100% - 15px),
    0 15px
  );
}

.box {
  width: 200px;
  height: 100px;
  margin: 0 auto;
  background: linear-gradient(90deg, skyblue, blue);
  clip-path: polygon(
    0 0,
    calc(100% - 50px) 0,
    100% 50%,
    calc(100% - 50px) 100%,
    0 100%,
    50px 50%
  );
}
```

:::

> 具体效果可查看 [drop-shadow 模拟边框](https://codepen.io/duyidao/pen/KwVyWQM)

> [!WARNING] 注意
> 想要实现效果，需要注意 `filter: drop-shadow()` 需要添加在父元素上，因为 `drop-shadow()` 是创建一个符合当前元素本身形状的阴影，因此需要将阴影作用在父元素上。

### clip-path 的坐标可以是负数，可以超出 100%
