# 性能优化

性能方面着重考虑两点：首屏速度和操作速度。首屏速度顾名思义，就是刚进页面获取资源渲染页面的速度；操作速度是用户在点击、输入等操作后需要等待的时间。

下面依次细说。

## 首屏速度，白屏时间等

先来分析一下首屏速度的组成：

![首屏速度组成](https://pic.imgdb.cn/item/66271db80ea9cb14030c2af7.png)

从图不难看出，在浏览器打开页面，需要先从服务器获取资源，获取完资源后才能执行 `js` 文件，这部分时间就是白屏时间；执行完 `js` 文件后请求数据，渲染 DOM 元素，这部分是渲染时间。

在白屏时间中执行 `js` 文件的速度一般情况下是很快的，除非项目用到了大的算法。因此大多数项目白屏时间主要在从服务器请求资源的这段时间。如果是 Vue 或 React 项目，它们的 `index.html` 内是没有东西的，请求到资源后还需要执行，这又消耗了一定的时间。

执行完 `js` 文件后浏览器开始渲染页面，发 `axios` 请求获取数据渲染真实 DOM，最后页面呈现数据。

针对上述描述，关于首屏速度优化可以做的操作从收益划分可以划分两类：

- 收益较大的操作：

  减少首屏资源提及（打包工具压缩、异步加载、减少体积、去除大的 `base64` 标识）

- 收益较小或特殊情况特殊分析的操作：

  1. 首屏数据尽量并行，小数据量的接口合并到其他接口
  2. 页面包含大量 DOM 可以分批随滚动渲染
  3. 骨架屏、loading等效果优化用户体验

### 打包工具压缩

这方面一般不需要去写什么代码逻辑，因为脚手架已经在打包时有压缩处理，如 `vite` 打包项目后会使用 `gzip` 压缩项目。

### 异步加载

异步加载不是简单的设置异步，而是需要考虑哪些资源需要异步加载，哪些资源不需要，继续保持同步。用一句话来概括就是，体积大且不是马上需要的资源，就采用异步加载。

举一个例子，项目中引入了第三方库实现 `excel` 和 `word` 资源转换与在线预览，但这两个库很大，在用户没有进入项目页面点击按钮执行操作时是用不到的，和首屏渲染没有关系，这部分的代码可以做异步加载。

### 更新

现在的打包工具有一个利器 `tree-shaking` ，它能够实现项目打包时只打包项目需要使用的第三方库，不会全部打包，但是这需要第三方库支持 `tree-shaking` 。有一些老版本的库不支持，更新到最新版后或许会支持，也能减少体积。

在实际项目中，可以通过排查项目使用的第三方依赖，卸载老版本的第三方库，引入新版本的第三方库，把全部导入修改为按需导入，利用 `tree-shaking` 的机制，能够大大减少打包后的体积，加快项目首屏渲染速度。

### 减少库的使用

有些时候，能不用第三方库自己写代码就不要用第三方库。例如时间格式化，自己写一个相关函数可能只需要 3kb ，引入第三方库可能还需要更大。

### 减小体积

修改代码，保持精简，积少成多，打包后能更精简。大的图片不要转 `base64` ，图片的渲染不会影响首屏加载的速度，大图不转 `base64` 还能减小代码体积。

## 操作速度以及渲染速度

以下几种情况会造成操作卡顿和渲染慢：

1. 一次性操作大量的 DOM
2. 进行复杂度很高的运算（如循环、递归）
3. Vue 和 React 项目中，不必要的渲染太多

这里主要展开第三点，在 Vue 项目中有依赖收集，配合 Vue3 静态节点标记，基本上避免了因数据改变引起的无意义渲染。只需考虑以下情况：

1. 频繁切换显隐内容使用 `v-show` 来控制，打开决定显隐内容使用 `v-if` 控制
2. 循环、动态切换的内容添加 `key` 值
3. `keep-alive` 缓存
4. 区分请求粒度，减少请求范围，减少更新

其中谨慎缓存接口数据。只有不变数据，定期时效可以缓存在 `cookies` 或者 `localstorage` 中，比如 `token` ，用户名等。

可以考虑做一个缓存队列存于内存中（全局对象，vuex）。这样能保证刷新就更新数据，也能一定程度上缓存数据。

## webworker提升性能

众所周知，JavaScript 一直被说不擅长计算，因为它是同步的，大规模计算会让主线程堵塞，结果就是界面完全卡死。

## 异步

而异步并不是最终最优的解决方案，异步只是把任务发布出去等待，后面还是会拉到主线程执行，异步不可能再异步队列自己执行。所以是一个耗时很高的操作，无论做不做异步，它始终都会导致页面卡死。

异步处理耗时运算

![异步处理耗时运算](https://pic1.imgdb.cn/item/679338bdd0e0a243d4f7772e.png)

如果一个耗时任务必须消耗 2s 去计算，主线程永远不可能躲开这 2s 的计算时间，只能通过切片等操作，把这 2s 的切片分为好几个 几十毫秒，一点点计算来解决卡顿问题。

## webworker

![webworker](https://pic1.imgdb.cn/item/679339a9d0e0a243d4f7775b.png)

webworker 是真正的多线程，开一条支线让它计算，然后把结果返回。需要注意的是，webworker 不能使用本地的 `js` 文件，只能使用线上的，解决方法为把需要使用的 `js` 文件放到 `public` 文件夹下，发布上线后让后端或运维把它丢到静态资源下即可。

::: code-group
```vue [App.vue]
<script>
let worker = new Worker('http://localhost:3000/worker.js', { type: 'module' })
worker.addEventListener('message', (e) => {
  console.log(e.data)
})
</script>

<template>
  <button @click="() => worker.postMessage('你好👋')">click me</button>
</template>
```
```js [worker.js]
let a = 2
self.postMessage(a) // 把数据返回给主线程

// 监听主线程传了什么
self.addEventListener('message', (e) => {
  console.log(e.data) // 主线程传来的数据
  self.postMessage('收到🫡') // 把数据返回给主线程
})
```
:::

### 注意事项

1. webworker 不能使用本地文件，必须是网络上同源文件
2. webworker 不能使用 window 上的 DOM 操作，也不能获取 DOM 对象，DOM 相关的东西只有主线程有，webworker 只能做计算相关的操作
3. 有的东西无法通过主线程传递给子线程，比如说 DOM 节点、对象特殊设置（如 `freeze` 、`getter` 等，Vue 响应式对象无法传递）
4. 模块的引入问题
   
   因为 webworker 只能使用网络上的文件，所以不能使用 `import` ，只能使用 `importScripts` ，且括号内只能写网络地址，不过该地址可以跨域。
   
   如果引用的 `js` 文件是 esmodule 规范的话，webworker 必须要加类型描述说明，否则会报错。

   如果使用了 `type` 为 `module` 那么无需使用 `importScripts` ，直接使用 `import` 即可。

## 常见应用

1. `webgl` 、`canvas` 等可视化操作，如在线滤镜、在线绘图、web 游戏等耗时计算可以使用 webworker

    ::: code-group
    ```js [普通使用.js]
    function img () {
      const data = ctx.getImageData(0, 0, 1800, 900)
      for (let i = 0; i < data.data.length; i++) {
        for (let j = 0; j < 255; j++) {
          if (data.data[i] !== 255) data.data[i] = Math.min(data[i] + j, 0)
        }
      }

      ctx.putImageData(data, 0, 0) // 耗时2s
    }
    ```
    ```js [worker.js]
    self.addEventListener('message', (e) => {
      if (e.data.data.length) {
        let data = e.data
        for (let i = 0; i < data.data.length; i++) {
          for (let j = 0; j < 255; j++) {
            if (data.data[i] !== 255) data.data[i] = Math.min(data.data[i] + j, 0)
          }
        }
        self.postMessage(data)
      }
    })
    ```
    ```vue [app.vue]
    <script>
    let worker = new Worker('http://localhost:3000/worker.js', { type: 'module' })
    worker.addEventListener('message', (e) => {
      console.log(e.data)
      ctx.putImageData(e.data, 0, 0)
    })

    function img () {
      const data = ctx.getImageData(0, 0, 1800, 900)
      worker.postMessage(data)
    }
    </script>
    ```
    :::

2. 一些涉及到大量数据大量计算如10万条数据导出 `excel` 表格的电子表单等后台管理系统也会涉及到 webworker

   前面提到过 webworker 只能使用线上地址， `import` `node_module` 的 `xlsx` 库会报错，所以需要寻找 `xlsx` 线上的 CDN 并把 `js` 文件放到 `public` 文件夹下，然后通过 `importScripts` 引入。

   ::: code-group
   ```js [worker.js]
   importScripts('./xlsx')
   let arr = []
   for (let i = 0; i < 100000; i++) {
     arr.push({
      id: 1,
      name: '张三' + i + '号',
      age: 18 + i,
      sex: i % 2 === 0 ? '男' : '女',
      phone: '1234567890' + i
     })
   }
   self.addEventListener('message', (e) => {
     const sheet = XLSX.utils.json_to_sheet(arr)
     const workbook = XLSX.utils.book_new()
     XLSX.utils.book_append_sheet(workbook, sheet, 'Sheet1')
     self.postMessage(workbook) // 保存文件涉及到 DOM 操作，因此要转移出去
   })
   ```
   ```vue [app.vue]
   <script>
   import { writeFile } from 'xlsx'

   let worker = new Worker('http://localhost:3000/worker.js', { type: 'module' })
   worker.postMessage('')
   worker.addEventListener('message', (e) => {
     writeFile(e.data, 'test.xlsx')
   })
   </script>
   ```
   :::

## 总结

webworker 用于处理前端性能瓶颈问题，只有涉及到大量计算才会使用 webworker。webworker 也有很多使用限制，如不能使用 DOM 操作、不能使用本地文件、不能使用 `import` 等。